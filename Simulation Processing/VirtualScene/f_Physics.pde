
//physical laws and constants, loaded with default values on contruction
class PhysicsLaws{
  float g=9.81;             //g constant in m/s^2
  float[] G={0,0,-1*g};
  float GplaneCollisionD = 0.005;  //distance between foot and gplane to trigger collision
}
PhysicsLaws LawsStd = new PhysicsLaws();


//object containing and used to compute physical parameters,
//  that influence and are influenced by Cspace objects 
class Pspace{
  PhysicsLaws Laws;     //set of laws used by this object

  //stuff about the linked Cspace
  Cspace C;

  //centre of mass motion in S frame
  float[][] Tcom_s;
  float[][] Ts_com;
  float[] P={0,0,0};    //linear position
  float[] A={0,0,0};    //angular position
  float[] V={0,0,0};    //linear velocity
  float[] W={0,0,0};    //angular velocity
  float[] dV={0,0,0};   //linear acceleration
  float[] dW={0,0,0};   //angular acceleration

  //Ground plane in S frame, predicted from sensors
  //S frame origin is not necesseraly on the G plane
  float[] GplaneO = {0,0,0};
  float[] GplaneNorm = {0,0,1};

  //indicates different physical states for the robot, in order:
  //  free fall, touching 2 feet, right foot, left foot
  int PreviousGravState = 0;
  int GravState = 0;

  //store feet position on ground after landing
  //used to anchor the feet at this point until it is released from ground
  //not updated while foot is not on ground-> keeps value of last landing
  float[] GroundFootR = {0,0,0};
  float[] GroundFootL = {0,0,0};
  
  //force created on the end effectors origin
  //  theese forces create a backlash force on the robot (opposite of Fact) in their acting point
  float[] FactR = {0,0,0};
  float[] FactL = {0,0,0};
  //normal and tangential component of the backlash forces with respect to the COM
  float[] FbackRnorm = {0,0,0}; float[] FbackRtan = {0,0,0};
  float[] FbackLnorm = {0,0,0}; float[] FbackLtan = {0,0,0};
  //support force generated by the legs, applied in the Hip2Joint origin
  //found by projecting Fg onto Hip2Joint z axis and scaling by the cosines of the legs
  float[] FsuppR = {0,0,0}; float[] FsuppL = {0,0,0};
  //effective force on the COM, sum of external forces and normal backlash forces
  float[] Feff = {0,0,0};
  float[] TQeff = {0,0,0};
  float TQeffQuadr = 0;


  Pspace(PhysicsLaws l, Cspace c, float[] p, float[] a){
    Laws = l;
    VCopy(P,p); VCopy(A,a);
    Tcom_s = T(Rot(A),P);
    Ts_com = TInverse(Tcom_s);

    C = c;
    C.UpdateTcoms(Tcom_s,Ts_com);
  }
  //without linking Cspace, Cspace virtual parameters have to be set manually
  Pspace(PhysicsLaws l, float[] p, float[] a){
    Laws = l;
    VCopy(P,p); VCopy(A,a);
    Tcom_s = T(Rot(A),P);
    Ts_com = TInverse(Tcom_s);
  }

  //update externally the physical parameters (like from Sense.Update())
  void UpdateParams(float[][] t, float[][] ti, float[] p, float[] a, float[] v, float[] w){
    MCopy4(Tcom_s,t); MCopy4(Ts_com,ti);
    VCopy(P,p); VCopy(A,a); VCopy(V,v); VCopy(W,w);
  }
  
  //physics engine functions, that modify this object's parameters
  //update the forces generated by the feet
  void UpdateFactRL(float[] fr, float[] fl){
    VCopy(FactR,fr); VCopy(FactL,fl);
  }
  
  //execute a time tick (in seconds) of duration dt on this object
  void Tick(float dt){
    //determine GravState by checking feet collision with ground plane
    boolean FootROnGround = (VDot(VSub(C.FootR,GplaneO),GplaneNorm)<Laws.GplaneCollisionD);
    boolean FootLOnGround = (VDot(VSub(C.FootL,GplaneO),GplaneNorm)<Laws.GplaneCollisionD);
    if(FootROnGround){if(FootLOnGround){ GravState = 1; }else{ GravState = 2; }}
    else{if(FootLOnGround){ GravState = 3; }else{ GravState = 0; }}

    
    //free fall
    if(GravState==0){
      //jump has happened
      if(PreviousGravState!=0){
        VNull(FactR); VNull(FactL);
        VNull(FbackRnorm); VNull(FbackRtan); VNull(FbackLnorm); VNull(FbackLtan);
        VNull(Feff); VNull(TQeff); TQeffQuadr = 0;
      }

      //free fall body dynamics
      Feff = VScale(C.Mass,Laws.G);
      dV = Laws.G; VNull(dW);

      //testt!^!!!!
      //dV = RealController.COMdVtarg;

      VAddInplace(V,VScale(dt,dV)); VAddInplace(W,VScale(dt,dW));

      //testt!^!!!!
      //V = RealController.COMVtarg;

      VAddInplace(P,VScale(dt,V)); VAddInplace(A,VScale(dt,W));
      Tcom_s = T(Rot(A),P);
      Ts_com = TInverse(Tcom_s);

      C.UpdateTcoms(Tcom_s,Ts_com);

    }else{
      //update ground feet positions if necessary
      if(PreviousGravState!=GravState){
        boolean Rcollision=false; boolean Lcollision=false;
        if(PreviousGravState!=1){
          if(GravState==2){ Rcollision = true; }
          else if(GravState==3){ Lcollision = true; }
          else{
            if(PreviousGravState==0){ Rcollision = true; Lcollision = true; }
            else if(PreviousGravState==2){ Lcollision = true; }
            else{ Rcollision = true; }
          }
        }
        if(Rcollision){ GroundFootR=C.FootR; VSubInplace(GroundFootR,VScale(VDot(GroundFootR,GplaneNorm),GplaneNorm)); }
        if(Lcollision){ GroundFootL=C.FootL; VSubInplace(GroundFootL,VScale(VDot(GroundFootL,GplaneNorm),GplaneNorm)); }
      }

      //compute backlash forces given the current act forces
      FbackRnorm = VScale(VDot(VOpposite(FactR),C.COMFootR)/VQuadr(C.COMFootR),C.COMFootR);
      FbackLnorm = VScale(VDot(VOpposite(FactL),C.COMFootL)/VQuadr(C.COMFootL),C.COMFootL);
      FbackRtan = VSub(VOpposite(FactR),FbackRnorm); FbackLtan = VSub(VOpposite(FactL),FbackLnorm);

      //compute total forces on COM
      Feff = VAdd(VScale(C.Mass,Laws.G),VOpposite(VAdd(FactR,FactL)));
                  //VAdd(FsuppR,FsuppL));
      TQeff = VAdd(VCross(C.COMFootR,FbackRtan),VCross(C.COMFootL,FbackLtan));
                  //,VAdd(VCross(VSub(C.J[2].Ts[3],P),FsuppR),VCross(VSub(C.J[6].Ts[3],P),FsuppL)));
      TQeffQuadr = VQuadr(TQeff);

      //compute total force effects on COM
      dV = VScale(1/C.Mass,Feff);
      if(TQeffQuadr>1e-6){ dW = VScale(1/C.Itot(Tcom_s[3],VScale(1/sqrt(TQeffQuadr),TQeff)),TQeff); }else{ VNull(dW); }

      //compute COM motion
      VAddInplace(V,VScale(dt,dV)); VAddInplace(W, VScale(dt,dW));
      
      //debug, to nullify rotational drift simulation error
      W[1] = 0; W[2]  = 0;
      
      VAddInplace(P,VScale(dt,V)); VAddInplace(A,VScale(dt,W));
      Tcom_s = T(Rot(A),P);
      Ts_com = TInverse(Tcom_s);

      
      //only correct foot position to old ground position if its acting force goes down
      FootROnGround = true;//(VDot(FactR,GplaneNorm)<1e-6);
      FootLOnGround = true;//(VDot(FactL,GplaneNorm)<1e-6);

      C.Tcom_s = Tcom_s; C.Ts_com = Ts_com;
      //update the Cspace theta configuration to keep feets on ground points if needed
      if(GravState==2 && FootROnGround){ C.SetFootR(VTransf4D(GroundFootR,Ts_com)); }
      else if(GravState==3 && FootLOnGround){ C.SetFootL(VTransf4D(GroundFootL,Ts_com)); }
      else{
        if(FootROnGround && FootLOnGround){ C.SetFootRL(VTransf4D(GroundFootR,Ts_com),VTransf4D(GroundFootL,Ts_com)); }
        else if(FootROnGround){ C.SetFootR(VTransf4D(GroundFootR,Ts_com)); }
        else if(FootLOnGround){ C.SetFootL(VTransf4D(GroundFootL,Ts_com)); }
        else{ C.UpdateJ(); }
      }
    }

    PreviousGravState=GravState; 
  }
}


Pspace RealP;



void SetupPhysics(){
  float[] p={0,0,-RealC.FootR[2]};
  float[] w={0.05,0,0};

  RealP = new Pspace(LawsStd,RealC,p,w);
}
